/*
 * The rule of dread defines "I can do it" to mean "nobody will come after me if I do."
 * And so follows the Dread License: you may do with this software anything
 *	that doesn't increase the amount of dread in the world.
 * That includes removal or replacement of this comment.
 *
 * Your contributions to this code do not warrant mention in this comment.
*/

/*
 * multi.c: functions dependent on output format such as MIDI
*/

#ifndef FLEX_SCANNER
        #error "Please compile lex.tfm.c (generated by 'flex tfm.l') or use 'make tfm'."
        #include "STOP, SEE ABOVE"
#endif

const char *output[2] = {"out.mid","out.ly"};
const char *format[2] = {"MIDI","Lilypond"};

uint8_t * daT1 N;	// MIDI format and awaiting dump into out.mid
uint8_t * daT2 N;	// not MIDI format but what's useful to convert into MIDI...
			// ... meaning it'd have been MIDI but nonVLQ uint64s take place of VLQ times
size_t s[] =	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};	// sizes: plus one header before channels, and one for a space afterwards.
size_t * S = s;
uint64_t l[] =	{  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0  };	// time of last note in each channel
uint64_t * L = l;
uint64_t ss, sS;
#define LOC (ss=S[e])
#define GET (S[e]=(sS=S[e],ss))
#define GO (S[e]=sS)

int32_t szInd = 1;
char hasstf[] =	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
_Bool haskey[] =	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

uint32_t bmp(int8_t from, int32_t amt);
uint32_t bmp(int8_t from, int32_t amt) {
	for (int8_t i=LY?from:1; i<=szInd;) S[i++]+=amt; return S[szInd]-amt;
}


#define A		daT2[bmp(szInd,1)] =
#define Z	(VU 0)	[daT2=VU realloc(daT2,bmp(e,1)+1), (size_t)memmove(daT2+S[e],daT2+S[e]-1,S[szInd]-S[e])-1]=
#define B	*(VW	&daT2[bmp(szInd,4)]) =
#define C	*(VX	&daT2[bmp(szInd,8)]) =
#define AMTT 4
#define XX *VW(&(VU 0)	[daT2=VU realloc(daT2,bmp(e,AMTT)+AMTT), (size_t)memmove(daT2+S[e],daT2+S[e]-AMTT,S[szInd]-S[e])-AMTT])=
#define c(X,Y)	*(VX	((daT2=VU realloc(daT2,bmp(szInd,8)+8+(Y)))+S[szInd]-8)) = (X)
#define s(X)		daT2=VU realloc(daT2,S[szInd]+sizeof(X)), memmove(daT2+S[szInd]+sizeof(X),daT2+S[szInd],0), S[szInd]+=sprintf(VC &daT2[S[szInd]],X)
#define t(X)		daT2=VU realloc(daT2,bmp(e,sizeof(X)-1)+sizeof(X)), memmove(daT2+S[e],daT2+S[e]-sizeof(X)+1,S[szInd]-S[e]),\
			memcpy(VC &daT2[S[e]-sizeof(X)+1],X,sizeof(X)-1)
#define tt(X)		daT2=VU realloc(daT2,bmp(e,strlen(X))+strlen(X)+1), memmove(daT2+S[e],daT2+S[e]-strlen(X),S[szInd]-S[e]),\
			VU memcpy(VC &daT2[S[e]-strlen(X)],X,strlen(X))	//for use with variable strings: slightly slower
#define ttt(...)	sS+=sprintf(VC f,__VA_ARGS__),\
			daT2=VU realloc(daT2,bmp(e,strlen(VC f))+strlen(VC f)+1), memmove(daT2+S[e],daT2+S[e]-strlen(VC f),S[szInd]-S[e]),\
			VC memcpy(VC &daT2[S[e]-strlen(VC f)],f,strlen(VC f))	//feat. sprintf


/*
	example in:  00000000 11110000 10101010 11111111
	example out: 11111111 10101010 11110000 00000000
	necessary for byte order required by MIDI specification
*/
//uint32_t FLIPINT (CN uint32_t i) { return
//			i<<24|i<<8>>16<<16|i>>8<<16>>16|i>>24;}
# define FLIPINT(i)	i<<24|i<<8>>16<<16|i>>8<<16>>16|i>>24

/*
	create MIDI variable length quantity from friendly integer
	example input:   0000 0001111  0001111  0001111  0001111
	example output:      10001111 10001111 10001111 00001111
	first bit of byte:   1        1        1        0
	which means:         ^keep reading septets......now stop.
	this is before flipping the four bytes to be writeable as needed
*/
//uint32_t FORMVLQ (CN uint32_t i) { return
//		 	i>>28?yyerror(0,"VLQ above limit 2^28-1!"):0x808080U|i>>25|i<<11>>25<<8|i<<18>>25<<16|i<<25>>1;}
# define FORMVLQ(i)	i>>28?yyerror(0,"VLQ above limit 2^28-1!"):0x808080U|i>>25|i<<11>>25<<8|i<<18>>25<<16|i<<25>>1

/*
	return friendly integer from MIDI variable length quantity
	also flips the four bytes to be readable
*/
//uint32_t QUITVLQ (CN uint32_t i) { return
//		 	 i^0x808080?i>>24|i<<9>>25<<7|i<<17>>25<<14|i<<25>>4:0;}
# define QUITVLQ(i)	(i^0x808080?i>>24|i<<9>>25<<7|i<<17>>25<<14|i<<25>>4:0)

#define T uint64_t tM
#define TC uint64_t tM, int e
#define LR if (LY) return;

#define PRPSTAF if (LY&&!hasstf[e])					hasstf[e]=1,t("\\new Staff {\n");
#define PRPKEYS	if (LY&&KEYSIG-'x') if(!haskey[e]?haskey[e]=1:0)	t("\\key "),Z KEYSIG,KEYMIN?t(" \\minor\n"):(t(" \\major\n"))
char KEYSIG = 'x', KEYMIN = 0;

#define FORRS for (uint32_t *(CLL(f)16),m,x,sh=1,yy=0; x=0,m=L[e]/ *vM<tM/ *vM?*vM-L[e]%*vM:tM-L[e],L[e]<tM?LOC,Z 'r':(F f); dn==0?l[e]+=m:0) DODR('r')
#define FORDR for (uint32_t *(CLL(f)16),m,x,sh=1,yy=0; x=0,m=dr>*vM-L[e]%*vM?*vM-L[e]%*vM:dr,dr?dr-=m,m:(F f); e[dn?L:l]+=m,L[e]>l[e]?l[e]=L[e]:0,dr?t("~ "):0)

#ifndef NOTRIP
#define DODR(c) do /*analyze default and two oddcases*/ \
		if (yy=m*vM[I]/ *vM-x>=vC[I]?vC[I]:m*vM[I]/ *vM-x, P0[I][yy]) /*P0 only true when duration is a tuplet*/ \
		for (uint32_t i=0,n=NM[I][yy]>1024?1024:NM[I][yy];n>>i++;) /*calculate bit width (63-tuplets display as 32nd notes)*/ \
			n>>i==0?sh?GET:0,\
			ttt("\\tuplet %u/%u {",NM[I][yy],1<<--i),\
			sh&&GO,ttt("%d",1<<i++), \
			Z '}',x+=vC[I]/NM[I][yy]:0;\
		else \
		for (uint32_t q=0,a=1,p=PW[I][yy/T1[I][yy]*B1[I][yy]],yp=vC[I]>>p,y=yp,z=0; ; ) \
			if (yy-yp&&a?yy-yp-z<y/2?a=0:1:(a=0))				z+=vC[I]>>p>>++q,Z '.',--S[e],y/=2; \
		else 	if (ttt("%d",1<<p),S[e]+=q,x+=yp*T1[I][yy]/vX[I]+z) break; \
		while (Z ' ',c=='~'?sh=0:(ANDAT LOC),m*vM[I]/vM[0]>x?Z c:0);
#else	//smaller code if never a tuplet
#define DODR(c) do for (uint32_t y=0,z=0,p=0,q=0,b=0,a=sh=yy=m*vM[I]/vM[0]-x>vC[I]?vC[I]:m*vM[I]/vM[0]-x; a&&vC[I]>>p>>1?yy<vC[I]-y?y+=vC[I]>>++p:++b:0 \
			||(ttt("%d",1<<p),S[e]+=q,x+=vC[I]>>p,x+=z,0);) \
			if (b?0==vC[I]>>p>>q>>1||yy-vC[I]+y-z<vC[I]>>p>>q>>1?a=0:1:0)	z+=vC[I]>>p>>++q,Z '.',--S[e]; \
		while (Z ' ',m*vM[I]/vM[0]-x?Z c:0);
#endif

#define ANDAT

/*u2 do_last (TC, uint64_t l_e) {u2 r={0,0,0,0,1,0}; (void) tM; (void) e; (void) l_e; uint64_t lst=0,lsn=0; (void) lst;  (void)lsn;
#ifdef DEBUG
//#define STOPP
#undef ANDAT
#define ANDAT Z '@',XX tM*vL/ *vM,
uint64_t timeSnap; size_t posnSnap, posnSnapMaybe;
size_t posn,dO;
uint32_t Depth=0; uint64_t (*CLL(times) Depth);
for (posn=S[e-1],dO=0;posn<S[e]?lst=r.t,1:++dO;++posn) {
	if (daT2[posn]=='<'&&daT2[posn+1]=='<') {printf("ANDFOUND!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"); ((ALL(times) ++Depth));times[Depth-1]=times[Depth-2];}
	if ((daT2[posn]=='@'&&(posnSnapMaybe=posn,1) || dO
		?(dO==0)?lsn=r.n,r.n=posn,r.t = *VW &daT2[posn+1]:0,
		r.t>=tM || dO?
			printf("WEFOUND! R.T %lu LS %lu CHN %lu\n", posn+1+AMTT, S[e]-9-1-AMTT, ss),
			daT2[posn]='\0',
				printf("WHICHIS '%c' '%c' '%c' '%c' ...... \n%s\n%lu VS %lu \n",daT2[posn+1],daT2[posn+2],daT2[posn+3],daT2[posn+4],&daT2[lsn+AMTT+1],lsn,posn),
			daT2[posn]='@',
			ss=posn+1+AMTT, GET, t("<<\n@"), XX r.t, Z'\n', sS+=5+AMTT, GO,
		r.n=(posn)+8: // for <<
	(posn+=AMTT,0):
0) break;
}
t(">>\n");
return r.n=S[e]-r.n,r;
#endif
//printf("WE FAILED! %d %d\n", e, szInd);
return r;}*/

u2 do_last (TC, uint64_t l_e) {u2 r={0,0,0,0,1,0}; (void) tM; (void) e; (void) l_e; uint64_t lst=0,lsn=0; (void) lst;  (void)lsn;
#ifdef DEBUG
//#define STOPP
#undef ANDAT
#define ANDAT Z '@',XX tM*vL/ *vM,
uint64_t timeSnap; size_t posnSnap, posnSnapMaybe;
size_t posn,dO;
uint32_t Depth=0; uint64_t (*CLL(times) Depth);
for (posn=S[e-1],dO=0;posn<S[e]?lst=r.t,1:++dO;++posn) {
	if (daT2[posn]=='<'&&daT2[posn+1]=='<') {printf("ANDFOUND!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"); ((ALL(times) ++Depth));times[Depth]=times[Depth-1];posn++;continue;}
	if (daT2[posn]=='|'&&daT2[posn+1]=='|') {printf("ANDBACK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");                        times[Depth]=times[Depth-1];posn++;continue;}
	if ((daT2[posn]=='@'&&(posnSnapMaybe=posn,1)) || dO
		?(dO==0)?lsn=r.n,r.n=posn,r.t = *VW &daT2[posn+1]:0,
		r.t>=tM || dO?
			printf("WEFOUND! R.T %lu LS %lu CHN %lu\n", posn+1+AMTT, S[e]-9-1-AMTT, ss),
			daT2[posn]='\0',
				printf("WHICHIS '%c' '%c' '%c' '%c' ...... \n%s\n%lu VS %lu \n",daT2[posn+1],daT2[posn+2],daT2[posn+3],daT2[posn+4],&daT2[lsn+AMTT+1],lsn,posn),
			daT2[posn]='@',
			ss=posn+1+AMTT, GET, t("<<\n@"), XX r.t, Z'\n', sS+=5+AMTT, GO,
		r.n=(posn)+8: // for <<
	(posn+=AMTT,0):
0) break;
}
t(">>\n");
return r.n=S[e]-r.n,r;
#endif
//printf("WE FAILED! %d %d\n", e, szInd);
return r;}


void do_rh (TC, CN uint32_t meas, CN uint32_t beg, CN _Bool pcusn, char tpose, CN char inst, uint64_t fro, CN uint64_t dn, CN uint64_t offf) { (void) offf; uint64_t offf_2=0;
	if (LY&pcusn&&(F aboveCs)|1) return;
	#define SHD 8
	#define SHP 4
	#define FLT 2
	#define FLD 1
	uint64_t FF[] = {fro,fro,fro,fro,fro,fro,fro,fro,fro,fro,fro,fro,fro,fro,fro,fro}, *L = dn?FF:l,
	dr = pcusn || LY ? dn ? dn : rhythmRetDur(meas,beg).t * *vM/vL : rhythmRetDur(meas,beg).t * nums[I] / dens[I];
	#ifdef DEBUG
	uint64_t dro = dr;
		printf("NEEDFOR %lu \n", dr);
	#endif
	static unsigned veloc_done = 0;
	size_t off = 0;
	if (dn) /*t("\t\\\\\n\t{{")*/; else {PRPSTAF; PRPKEYS;}
	if (hasstf[e]==1) t("@\0\0\0\0"), hasstf[e]=2;
	if (dn==0&&LY?l[e]>tM?DEBG?1:(F aboveCs)|(F isFlt)|(F velocs)|1:0:0) //return;
		{if(DEBG) {u2 u=do_last(tM*vL/ *vM,e,l[e]);off=u.n+0; printf("DO OFF %lu \n", off);if(!u.b) return; do_rh(tM,e,meas,beg,pcusn,tpose,inst,l[e]-u.t,dr,off);/*if(u.b)t("}}\n>>\n");*/ } return;}
	if (LY&&dn==0)	FORRS;
	if (LY) dn?S[e]-=(offf_2=offf/*-1+AMTT*/):0,LOC,Z '<';
	else	switch(inst+1) {
		case 25://Guitar...
		case 26://...
		case 27://...
		case 28://...
		case 29://...
		case 30://...
		case 31://...
		case 32://...
		case 33://Bass guitar...
		case 34://...
		case 35://...
		case 36://...
		case 37://...
		case 38://...
		case 39://...
		case 40://...
		case 44://Contrabass
			tpose-=12; break;
		case 9://Celesta
		case 14://Xylophone
		case 73://Piccolo
			tpose+=12; break;
		case 10://Glockenspiel
			tpose+=24; break;
	}

	for (int32_t numC = *aboveCs, velNow; numC||(F aboveCs)|(LY?Z '>',(F isFlt):0)|(F aboveCs); --numC) {
		if (velocs NN) {
			velNow = velocs[++veloc_done];
			if (veloc_done == *velocs) {veloc_done = 0, FREE(velocs);}
		} else velNow = (uint8_t) veloc;
		if (!LY?c(tM,pcusn?3:14),
			A 0x90+e, A 0x3c+aboveCs[numC]+tpose, A velNow?velNow:1, pcusn==0?C (uint64_t)(tM+dr),
			A 0x80+e, A 0x3c+aboveCs[numC]+tpose, A velNow?velNow:1 :1:0)
			continue; //else
		Z 'a' + (aboveCs[numC]+49)%7;
		isFlt[numC]&&isFlt[numC]<=FLT?t("es"),isFlt[numC]==FLD?t("es"):0: isFlt[numC]>=SHP?t("is"),isFlt[numC]==SHD?t("is"):0:0;
		if (aboveCs[numC]<0) ++aboveCs[numC];
		for (int i=(aboveCs[numC]-2)/7+(aboveCs[numC]-2>=0); !i?Z ' ',0:1; aboveCs[numC]-2>=0?--i:++i)
			Z aboveCs[numC]-2>=0? '\'' : ',';
	}
	if (LY) FORDR DODR('~');
	if (LY) if (dn) S[e]+=AMTT+1,t("\n\t\\\\"), S[e]+=offf_2-AMTT-1;
	if (LY) if (!dn) Z '\n';
	#ifdef DEBUG
	if (LY) if (!dn) Z'@', XX tM*vL/ *vM + dro,printf("DIDDUR %lu \n",tM*vL/ *vM + dro*vL/ *vM);	//remember the @ at zero
	#endif
}

#define dn 0

void do_cc (TC, CN uint8_t f, CN uint8_t v) { LR
	c(tM,5);
	A 176|e;
	A f;
	A v;
}

void do_meta (T, CN char type, CN uint32_t l) { LR
	c(tM,l+6);
	A 0xFF;
	A type;
	B FORMVLQ(l);
}

void do_copyr		(CN char *t) { LR uint32_t l = strlen(t); do_meta(
0,		0x02,l); while (l-->0) A(*t++==ALTSPC?' ':*(t-1));}

void do_title		(CN char *t) {int32_t e; if (LY? e=-1,t("title = \""),tt(title),t("\"\n"):0) return;
		uint32_t l = strlen(t); do_meta(
0,		0x03,l); while (l-->0) A(*t++==ALTSPC?' ':*(t-1));}

void do_instname	(CN char *t) { LR uint32_t l = strlen(t); do_meta(
0,		0x04,l); while (l-->0) A(*t++==ALTSPC?' ':*(t-1));}

void do_lyrics		(TC, CN char *t) {(void)e; LR uint32_t l = strlen(t)+1; do_meta(
tM,		0x05,l--); while (l-->0) A(*t++==ALTSPC?' ':*(t-1)); A ' ';}

void do_tms		(T, uint32_t perQNuSec) { LR do_meta(
tM,		0x51,3); A perQNuSec>>16; A perQNuSec>>8; A perQNuSec>>0;}

void do_tmsig		(TC, CN uint8_t n, CN uint8_t d, /*CN uint8_t perClocks, CN uint8_t perbeat32,*/ CN char *timesig, int64_t m){
		if (Do==TO?(ALL(oF)++vN),I[(ALL(of)vN)]=-m,I[(ALL(nums)vN)]=n,I[(ALL(dens)vN)]=d:TO) return;
		else oF[I] = (long int) tM * (dens[I]-nums[I]) / dens[I];
		if (LY) {PRPSTAF;FORRS;t("\\time ");tt(timesig);Z '\n'; return;} /*do_meta(
0,		0x58,4); A num; A denom; A perClocks; A perbeat32; int x=tM; x=x; */ }

void do_keysig		(TC, char letter, char numSharps, _Bool isMinor) { KEYSIG=letter; KEYMIN=isMinor; (void) e; LR do_meta(
tM,		0x59,2); A numSharps; A isMinor; }

void DO_keysig		(TC, CN char letter, CN _Bool isMinor) {if (!LY) return; (void) tM;
	PRPSTAF;
	t("\\key ");
	Z letter + 'a';
	if (isMinor) t(" \\minor\n"); else t(" \\major\n");
	haskey[e]=1;
}

void do_clef		(TC, CN char clef) {if (!LY) return;
	PRPSTAF; PRPKEYS; FORRS;
	if (clef=='C')	t("\\clef alto\n");
else	if (clef=='F')	t("\\clef bass\n");
else	if (clef=='G')	t("\\clef treble\n");
else	if (clef=='t')	t("\\clef tenor\n");	return;}


void do_instrument (TC, CN uint8_t inst) { LR
	c(tM,2);
	A 0xC0+e; A inst-1;
}

void do_before(void) {
	++S; int32_t e;
	if (LY)
		szInd=17,
		e=-1, t("\\header {\n"), e=0, t("}\n\\version \"2.24.1\"\n<<\n"),
		e=16, Z ' ';
}

void do_after (T) { uint32_t poS1 = 0, poS2 = 0;
printf("Now assembling %s file...\n", format[LY]);
if (!LY)
for (uint16_t ireadMany=0, writeMany=4; S[szInd]+8>(poS2+=writeMany-4+8); ) {
	uint32_t valuMidi = 0, toWrite = 0;
	uint64_t valuInit = *VX&daT2[poS2-8], lastAftCum = 0, preCum = 0; //lol
	if	(daT2[poS2]>>5==9>>1)	writeMany=7;	//midi note (9>>1==8>>1)
	else if	(daT2[poS2]>>4==11)	writeMany=7;	//midi control change
	else if	(daT2[poS2]>>4==12)	writeMany=6;	//midi program change (instrument)
	else if	(daT2[poS2]>>4==15)			//midi tempo or lyric
			writeMany= QUITVLQ(*VW&daT2[poS2+2]) + 10;
	for (poS1=-ireadMany;S[0]>(poS1+=ireadMany);)	{
		if	(daT1[poS1+4]>>5==9>>1) ireadMany=7;	//midi note
		else if	(daT1[poS1+4]>>4==11)   ireadMany=7;	//midi control change
		else if	(daT1[poS1+4]>>4==12)   ireadMany=6;	//midi program change (instrument)
		else if	(daT1[poS1+4]>>4==15)   		//midi tempo or lyric
			ireadMany= QUITVLQ(*VW&daT1[poS1+6]) + 10;
		preCum = lastAftCum;
		valuMidi	 = QUITVLQ(*VW&daT1[poS1]);
		if (valuInit >= lastAftCum + valuMidi)
			lastAftCum = preCum + valuMidi;
		else {	//we found insertion point. step back and break
			toWrite = FORMVLQ((uint32_t)(lastAftCum + valuMidi - valuInit));
			preCum -= valuMidi; break;
		}
	} (ALL(daT1)	S[0]+writeMany); if (S[0]-poS1)
	*VW memmove(daT1+poS1+writeMany,daT1+poS1,S[0]-poS1) = toWrite; S[0]+=writeMany;
	*VW memcpy (daT1+poS1,-4       +daT2+poS2,writeMany) = FORMVLQ((uint32_t)(valuInit - preCum - valuMidi));
} else {for (int32_t e=-1, on=1; ++e<=szInd; ) if (hasstf[e]) {FORRS;if (!on?on=0:1) t("\\bar \"|.\""); t("\n}\n");}
#ifndef STOPP
  for (size_t p=0, e=0;p<S[szInd];++p>S[e]?++e:0) if (daT2[p]=='@') memmove(daT2+p,daT2+p+AMTT+1,S[szInd]-p-AMTT-1), bmp(e,-(AMTT+1));
#endif
}

FILE*	file = fopen(output[LY],"wb");
#define PP(x) fputc(x,file)
if (!LY)
  fputs("MThd",file),PP(0),PP(0),PP(0),PP(6),PP(0),PP(0),PP(0),PP(1),PP(vL/1024),PP(vL/4),
  fputs("MTrk",file),
  poS2=FLIPINT(S[0]), fwrite(&poS2,1,4,file);	//FLIPINT() may be htonl() if .h's accounted for
fwrite(LY?daT2:daT1, 1, LY?S[szInd]:S[0], file);
if (!LY) PP(0x00),PP(0xFF),PP(0x2F),PP(0x00);
else fputs(">>",file);
#undef PP

fclose(file);

//if (!LY) file = fopen("out2.mid","wb"), fwrite(daT2,*S,1,file), fclose(file);

free(daT1); //free(daT2);// in main.c

printf("%s file created at %s!\n", format[LY], output[LY]);

}
