%top{
/*
 * The rule of dread defines "I can do it" to mean "nobody will come after me if I do."
 * And so follows the Dread License: you may do with this software anything
 *	that doesn't increase the amount of dread in the world.
 * That includes removal or replacement of this comment.
 *
 * Your contributions to this code do not warrant mention in this comment.
*/

/*
 * This is Text Format Music.
 * Compile lex.tfm.c, which is generated by "flex tfm.l".
 * You'll need two files from the same webpage: main.c and multi.c.
 * http://24.94.227.219/tfm/
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>

long long unsigned gcd(long long unsigned a, long long unsigned b) {return b?gcd(b,a%b):a;}

#ifndef __cplusplus
  #undef __INT8_C
  #define __INT8_C(x)
#endif
#define ALL(x) 	x)= __INT8_C((typeof(x)))	realloc(x,sizeof(*x) *
#define CLL(x) 	x)= __INT8_C((typeof(x)))	calloc(sizeof(*x) ,
#define  N  =NULL
#define EN ==NULL
#define NN !=NULL
#define FREE(x) free(x),x=NULL
#define F 0)|FREETURN((char**) &
uint8_t FREETURN(char** ptr);
uint8_t FREETURN(char** ptr) {free(*ptr); *ptr N; return 0;}
#define CN const
#define VC (char*)
#define VU (uint8_t*)
#define VV (uint16_t*)
#define VW (uint32_t*)
#define VX (uint64_t*)
#define PRNTIF(x,y) (printf("%.*s", -(y), x))
#define IF(...) if((__VA_ARGS__))

#define TET 12
#define DIAT(x) (x+(x>=3)+(TET>=12&&x>=TET-4))/2
#define DIATT(x) (DIAT((x+3)%12)+5)%7
#define CHR(x) (x*2 - (x>=2) - (TET>=12&&x*2>TET-4)) + 12
#// CHR() is function from [0...6] to [0...11]: that is, A-G diatonic to A-G# chromatic
CN int8_t SHR[] = { 3, -2,  5,  0, -5,  2, -3,  4, -1, -6,  1, -4, 3, -2,  5,  0, -5,  2, -3,  4, -1, -6,  1, -4 };
#// to know which keys have which keysigs (negative is flats)
#define FF(b) if (a>127) printf(b,a=127), putchar('\n')
#define HF(b) if (a>63) printf(b,a=63), putchar('\n'); else if (a<-64) printf(b,a=-64), putchar('\n')

#define do(x,...) do##x(LY?tM* *vM/vL:Do?((tM+of[I])*nums[I]/dens[I])+oF[I]:tM*vL/ *vM, YTR channel, __VA_ARGS__)
#define DO(x,...) DO##x(LY?tM* *vM/vL:Do?((tM+of[I])*nums[I]/dens[I])+oF[I]:0         , YTR channel, __VA_ARGS__)

}
		#// everything before "%%" not sequential in generated code - look for double indents.
		#if (100*YY_FLEX_MAJOR_VERSION+10*YY_FLEX_MINOR_VERSION+YY_FLEX_SUBMINOR_VERSION != 264)
		  #warning "Code is written for Flex version 2.6.4 (maybe 2.6.2/3)."
		#endif

		#// reentrant kept available: just add Flex option "reentrant", which defines YY_TYPEDEF_YY_SCANNER_T
		#ifndef YY_TYPEDEF_YY_SCANNER_T
		  #define YYG
		  #define SCAN
		  #define tfmlex_init(x) (void)0
		#else
		  #define YYG ((struct yyguts_t*)SCANNER1)->
		  #define SCAN SCANNER1
		  #define tfmset_extra(x,y) yy_user_defined = yy_user_defined //unbreak option noyyset_extra
		#endif// %option noyyget_lval noyyset_lval noyyget_lloc noyyset_lloc no effect; yy_scan_buffer if -DDOYY
%option		noinput nounput noyywrap noyy_scan_string noyy_scan_bytes noyyset_extra
%option		noyyget_extra noyyget_leng noyyget_textnoyyget_lineno noyyset_lineno
%option		noyyget_in noyyset_in noyyget_out noyyset_out noyyget_debug noyyset_debug
%option		nounistd never-interactive
%option		warn prefix="tfm" 8bit
		#// in spite of the alt prefix, let's allude to "yy" in the code
		#// except tfmlex_init/tfmlex_destroy and, for old Flex compatibility, these two:
		#define yy_load_buffer_state tfm_load_buffer_state
		#define yyensure_buffer_stack tfmensure_buffer_stack
%top{
//custom values to add to struct yy_buffer_state.
#define yy_fill_buffer yy_fill_buffer YY_BUFFER_STUFF
#define YY_BUFFER_STUFF ;\
  uint32_t charsAftTil;\
  int skipMany;\
  _Bool yy_buf_new;\
  int toQuit		// semicolon removed for -Wpedantic
  uint32_t **blksAt;	// removed from STUFF to participate in buffer creation
  uint32_t **blksDo;
typedef struct transfer trr;
trr *ytr N;
#define YTR ytr[YYG yy_buffer_stack_top].
#define INIT_BUF(buf) memset ((void*)(&buf), 0, sizeof(struct transfer)), buf.vEloc = 127
#define INIT_VEL(buf) memset ((void*)(&buf), 0, sizeof(struct transfer))
typedef unsigned UTRANS;
typedef int DTRANS;
struct transfer {
  UTRANS channel;
  UTRANS instrument;
  int vEloc;
  DTRANS transpose;
  DTRANS aboveC;
  DTRANS isFl;
}; // refer to generated lex.tfm.c for the rest and redefine YY_BUFFER_STUFF later:}
		#undef YY_BUFFER_STUFF
		#define YY_BUFFER_STUFF
%top{

#define	SKIPCH '\021' // also make Flex definition {_}, with: }
_		\021*
		#// skip is inserted into squarelines to overwrite note 1 so we can regex note 2, etc
		#// that is, if the skipchar were ~ rather than a control...
		#//	[]rh na--na
		#// would be regex'd easier if it became:
		#//	[]rh~~~~~na

		#//also define ALTSPC to allow true-to-width manpages:
		#define ALTSPC '`'
		//#define ALTSPC -73 // which is Â· ...doesn't work
NALT		[^` ]

%top{

#ifdef _MSC_VER
  #pragma warning( disable : 4996 ) // no secure functions please
  #pragma warning( disable : 4710 ) // quiet uninlined functions
  #pragma warning( disable : 4711 ) // quiet inlined functions
#elif defined(__GNUC__) && !defined(__clang__)
  #pragma GCC diagnostic warning "-Wall"
  #pragma GCC diagnostic warning "-Wextra"
  #pragma GCC diagnostic warning "-Wpedantic"
  #ifndef NOPT
  #pragma GCC optimize ("O4")
  #endif
  #ifndef EBUG
  #pragma GCC diagnostic ignored "-Wparentheses"
  #endif
  #//#pragma GCC diagnostic ignored "-Wimplicit-fallthrough" // let's use instead:
#endif
#define FALLTHROUGH_EOF	yy_act=YY_STATE_EOF(YY_START); goto do_action
#define FALLTHROUGH	/*if next isn't EOF*/++yy_act; goto do_action

#define YBS YYG yy_buffer_stack
#define YBT YYG yy_buffer_stack_top
#define YYC YBS[YYG yy_buffer_stack_top]
#define YYT yytext
#define YYL yyleng
#define YYP	(YYT+YYC->charsAftTil)
#define MYYL	(YYL-YYC->charsAftTil)
#define RETQUITIFLAST return YYG yy_buffer_stack_top--
#define BREAK(x) while (YYC->skipMany = x - 1, YYC->charsAftTil += x, YYC->toQuit = !YYG yy_hold_char, \
  YYG yy_start != 1 + 2 * INITIAL) RETQUITIFLAST;
#define BREAK_OVERRIDE(x) BREAK(x)
#define YY_BREAK BREAK(MYYL); break;

_Bool		VERBOSE = 0;
_Bool		DEBG = 0;
_Bool		LY = 0;
_Bool		TO = 0;
char		Do = 0;
_Bool		ANLZ = 0;
uint32_t	TOMEAS = 0;

uint64_t vL = 4, *vC N, *vX N, *vM N; int64_t *of N, *oF N;
uint32_t *nums N, *dens N, vN=1, I;
_Bool **P0 N; uint32_t **PW N, **NM N, **T1 N, **B1 N;

uint32_t veloc = 127, *velocs N;
long unsigned * tiMes N;
uint32_t tL;
uint64_t tM = 0;
uint64_t altTempo = 500000;

char * tx N; uint32_t txL;
uint32_t *begins N; // index in tx where each squareline begins
uint32_t *typLns N; // aka last in block: if finding beginning OF firstblock do (blk-1?typLns[blk-1]:0)

uint32_t **rhsAt N, **rhTyp N;
uint32_t *mBlkOff N, *mFro N, *mMid N, *mBak N, *mBlk N, *bMea N, *bSpc N;
 int32_t *aboveCs N; uint32_t *isFlt N;
#//char *widR;		//this is actually declared at the end of this file
#//char *measchr;	//this is actually declared at the end of this file

#define NUMBLK typLns[0]
#define NUM_LN begins[0]
#define NUMMEA mBlk[0]
#define TYPEGETPLUS velocs	//why wouldn't I?

typedef struct u2 {uint64_t t; uint64_t t2; uint64_t n; uint64_t n2; _Bool b; _Bool b2;} u2;
#define U22 {0,0,0,0,0,0}

u2 rhythmRetDur (uint32_t meas, uint32_t start);
static inline char push (CN uint32_t input, uint32_t ** ptr);
unsigned yyerror (void *nouse,char CN *msg); // I think param 1 was needed when I was using Bison
unsigned yyerror (void *nouse,char CN *msg){(void)nouse;exit(fprintf(stderr,"Parse error: %s\n",msg));return 1;}
void* SCANNER1; // such voidpointers would be cast to (yyscan_t) if it mattered
uint32_t topBlkLns;

char *title N, *copyr N;
uint32_t *repeatTo N, *repeatFr N;

#define CHK(x) if (!Do) vC[0] = vC[0] / gcd(vC[0], x) * x;
#define CHKK(x,...) if (x) CHK(mMid[meas1 /*__VA_ARGS__*/]/gcd(x,mMid[meas1 /*__VA_ARGS__*/]));

}
		#define YY_DECL \
		int doVeloc (int in) {size_t t=YBT;for(;ytr[YBT].vEloc+4==0;++t);ytr[t].vEloc=in; return in;} \
		size_t yylex (uint32_t meas1, uint32_t start2, uint64_t measTime3, void * yyscanner); \
		size_t yylex (uint32_t meas1, uint32_t start2, uint64_t measTime3, void * yyscanner)
	
		#include "multi.c"
	#//that's the end of the double-indent rule...

%x SQUARES MEASURES FIRSTRUN FIRSTMEAS
	#// CHK modify global variable and return negative if switch to float required (perhaps also excess of some amount)
	#define P	if (Do) BREAK(MYYL);
	#define Q	if (!Do) BREAK(MYYL);
	#define CQ	if (!Do) {CHK(mMid[meas1]); BREAK(MYYL);}
%%
	(void)yyscanner; // for gcc -Wextra
	if (YYG yy_start != 1 + 2 * INITIAL) {	// in which case we're in SQUARES or MEASURES or firstrun
		if (YYG yy_buffer_stack_top == topBlkLns-1)	veloc = 127;
		if ((YTR vEloc&3) + 1)				veloc = YTR vEloc;
		if (YYC->toQuit ||
		   YYC->skipMany ? YYC->skipMany-- : 0)		RETQUITIFLAST;
		if (YYG yy_hold_char) *YYG yy_c_buf_p = YYG yy_hold_char;
		if (YYC->yy_buf_new) YYC->yy_buf_new=0,
			YYC->yy_buf_pos = YYC->yy_ch_buf + blksAt[YBT][mBlk[meas1]-1];
		yy_load_buffer_state (SCAN);
		YYC->yy_at_bol = 1; //uint16_t k=4; except this was locked to length of []xx
		if (YYC->charsAftTil<blksDo[YBT][mBlk[meas1]-1])
			memset(&YYC->yy_buf_pos[4], SKIPCH, (YYC->charsAftTil-4));
		else IF (YYC->toQuit=1) RETQUITIFLAST;
	}
	#define CHARSAFTTILFIRST mBlkOff[toMeas] + mFro[toMeas]

<INITIAL>{
.	/*input lines not beginning in [...] are comments*/
^\[.*\]+.*$	{
	#define HERE /* lines in block */ meas1 
	#define mywid start2
	++HERE; push(txL+1,&TYPEGETPLUS);
	char * TMP = strcpy(VC calloc(YYL+3,1),YYT); //strndup not in Windows
	mywid=1; while (']'!=TMP[mywid++])	;
		 while (']'==TMP[mywid++])	;
	if (0U+YYL == mywid)			TMP[++mywid]=' ',++YYL;
	if (0U+YYL == mywid)			TMP[++mywid]=' ',++YYL;
	push(txL,&begins);
	memcpy(&txL[(ALL(tx)txL+YYL)],TMP,YYL); txL+=YYL;
	free(TMP);
}
\n	txL[(ALL(tx) txL+2)]=0; txL+=2;
^\].*$	FALLTHROUGH_EOF;
<<EOF>>	memcpy(&txL[(ALL(tx)txL+YYL)],YYT,YYL); txL+=YYL; return TYPEGETPLUS&&push(NUM_LN,&typLns)&&topBlkLns<HERE?topBlkLns=HERE:0, --YYL;
}


	/* After every rule, BREAK() is executed. */
	/* This is needed in <MEASURES> and <SQUARES>. */
	/* Override its behavior with BREAK_OVERRIDE() if needed. */
	/* And see SKIPCH about {_}. */

<SQUARES,FIRSTRUN>{
	/* THESE typelines are rhythm. */
	/* Any block consisting of no rhythm typelines is of zero duration. */
	/* So we pass an m4 preprocessor append, within a C comment, each time: */

	/* m4_define([[m4_append]],[[m4_define([[$1]],m4_ifdef([[$1]],[[m4_defn([[$1]])]])[[$2]])]]) */
	/* m4_append([[RHYMWID]],[[rh]]) */
^\[\]("rh"|"RH"){_}[NnDd]	{if (YYG yy_start == 1 + 2 * SQUARES) {
	YYT[YYL] = YYG yy_hold_char;
	if PRNTIF("NO PITCH FOUND! ", aboveCs EN)
		do putchar(*YYT-SKIPCH?*YYT:'.'); while (*++YYT-'\0'||!putchar('\n')); else
	do(_rh,meas1,start2,0,YTR transpose,YTR instrument,0,0,0);} else {
	CHKK(start2); u2 a=rhythmRetDur(meas1,start2); CHKK(a.t,+a.n); YY_BREAK;
}
}

	/* m4_append([[RHYMWID]],[[pc]]) */
^\[\]("pc"|"PC"){_}[0-9A-F]{2}	{CQ
	#// 2char percussion: hex value for any percussion event.
	uint32_t pit; sscanf(YYP,"%x",&pit);
	push (-0x3c /*which is C3*/ + pit ,(uint32_t**)&aboveCs);
	do(_rh,meas1,start2,1,0,0,0,0,0);
}

^\[\]("pc"|"PC"){_}[l-z]	{CQ
	#// 1char percussion: common events.
	switch (*YYP) {
		case 'z': *YYP=35-0x3c; break;	// Acoustic Kick
						// Electric Kick (36)
		case 'y': *YYP=46-0x3c; break;	// Open Hi-Hat
		case 'x': *YYP=38-0x3c; break;	// Acoustic Snare
						// Electric Snare (40)
		case 'w': *YYP=42-0x3c; break;	// Closed Hi-Hat
		case 'v': *YYP=51-0x3c; break;	// Ride Cymbal 1
						// Ride Cymbal 2 (59)
		case 'u': *YYP=49-0x3c; break;	// Crash Cymbal 1
		case 't': *YYP=57-0x3c; break;	// Crash Cymbal 2
		case 's': *YYP=50-0x3c; break;	// High Tom
						// High-Mid Tom (48)
						// Low-Mid Tom (47)
		case 'r': *YYP=45-0x3c; break;	// Low Tom
		case 'q': *YYP=37-0x3c; break;	// Side Stick
		case 'p': *YYP=44-0x3c; break;	// Pedal Hi-Hat
		case 'o': *YYP=53-0x3c; break;	// Ride Bell
		case 'n': *YYP=52-0x3c; break;	// Chinese Cymbal
		case 'm': *YYP=55-0x3c; break;	// Splash Cymbal
		case 'l': *YYP=54-0x3c; break;	// Tambourine
						// Cowbell (56)
	} push(*YYP,(uint32_t**)&aboveCs); *YYP='z';
	do(_rh,meas1,start2,1,0,0,0,0,0);
}

	/* THESE lines are not rhythm. */



^\[\]k:{_}[a-gA-G][#b]?(?i:" tigic"|" Locrian")		Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)-11+(YYP[1]&2?YYP[1]&1?1:-1:0)%12],0);
^\[\]K:{_}[A-G][#b]?(?i:" tigic"|" Locrian")		Q--*YYP;DO(_keysig,*YYP%32,0);
^\[\]k:{_}[A-G][#b]?(?i:" lamic"|" Aeolian"|" minor"|m)	Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)-9 +(YYP[1]&2?YYP[1]&1?1:-1:0)%12],1);
^\[\]K:{_}[A-G][#b]?(?i:" lamic"|" Aeolian"|" minor"|m)	Q--*YYP;DO(_keysig,*YYP%32,1);
^\[\]k:{_}[A-G][#b]?(?i:" sotic"|" Mixolydian")		Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)-7 +(YYP[1]&2?YYP[1]&1?1:-1:0)%12],0);
^\[\]K:{_}[A-G][#b]?(?i:" sotic"|" Mixolydian")		Q--*YYP;DO(_keysig,*YYP%32,0);
^\[\]k:{_}[A-G][#b]?(?i:" fatic"|" Lydian")		Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)-5 +(YYP[1]&2?YYP[1]&1?1:-1:0)%12],0);
^\[\]K:{_}[A-G][#b]?(?i:" fatic"|" Lydian")		Q--*YYP;DO(_keysig,*YYP%32,0);
^\[\]k:{_}[A-G][#b]?(?i:" mimic"|" Phrygian")		Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)-4 +(YYP[1]&2?YYP[1]&1?1:-1:0)%12],0);
^\[\]K:{_}[A-G][#b]?(?i:" mimic"|" Phrygian")		Q--*YYP;DO(_keysig,*YYP%32,0);
^\[\]k:{_}[A-G][#b]?(?i:" remic"|" Dorian")		Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)-2 +(YYP[1]&2?YYP[1]&1?1:-1:0)%12],0);
^\[\]K:{_}[A-G][#b]?(?i:" remic"|" Dorian")		Q--*YYP;DO(_keysig,*YYP%32,0);
^\[\]k:{_}[A-G][#b]?(?i:" dotic"|" Ionian"|" major")?	Q--*YYP;do(_keysig,*YYP+1,SHR[CHR(*YYP%32)+(YYP[1]&2?YYP[1]&1?1:-1:0)%12],0);
^\[\]K:{_}[A-G][#b]?(?i:" dotic"|" Ionian"|" major")?	Q--*YYP;DO(_keysig,*YYP%32,0);


^\[\]ap{_}[a-pA-P]	%{Q
	#//Access points: channels translated into MIDI channels.
	#//User not expected to know the MIDI rule that channel 10 (0x9) is percussion.
	#//Instead, it's A-P and the last one P is Percussion.
	YTR channel = --*YYP %32	//shift case
	^6; // = ^0b110: converts 0x15 to 0x9 for percussion
	VERBOSE?printf("CHANNELNOW %u ONBUF %zu\n",YTR channel,YBT):0;
%}
^\[\]ch{_}[a-pA-P]	%{Q
	#//MIDI channels, which are still denoted A-P.
	#//Channel J, which is channel 10, which is 0x9, is percussion.
	YTR channel = --*YYP %32;	//shift case
	VERBOSE?printf("CHANNELNOW %u ONBUF %zu\n",YTR channel,YBT):0;
%}

^\[\]("in"|"IN"){_}[0-9]{1,3}[a-gA-G]{0,1}	{ if (!Do) {CHKK(start2); YY_BREAK;}
	#// Instruments are decimal numbers as seen on the Wikipedia page for "General MIDI".
	#// I mean, you'll be referring there, won't you?
	uint32_t instrument; sscanf(YYP,"%u",&instrument); YTR instrument=instrument-1;
	do_instrument(measTime3,YTR channel,instrument);
	#define INSTOFF meas1
	INSTOFF=0; while((uint8_t)(YYP[INSTOFF]-'0')<=9) ++INSTOFF;
	switch (YYP[INSTOFF]) {
		case 'C': YTR transpose=0; break;
		case 'c':
		case 'B': YTR transpose=-1; break;
		case 'b': YTR transpose=-2; break;
		case 'A': YTR transpose=-3; break;
		case 'a': YTR transpose=-4; break;
		case 'G': YTR transpose=-5; break;
		case 'g': YTR transpose=-6; break;
		case 'F': YTR transpose=-7; break;
		case 'f':
		case 'E': YTR transpose=-8; break;
		case 'e': YTR transpose=-9; break;
		case 'D': YTR transpose=-10;break;
		case 'd': YTR transpose=-11;break;
		default: --INSTOFF;
	}
}

^\[\]Q:{_}[0-9]+	{Q
	#// Quarter-note tempo per minute.
	long unsigned thisTempo=0; sscanf(YYP,"%lu",&thisTempo);
	if (TOMEAS&&altTempo) altTempo=	60000000/thisTempo; else
	do_tms(measTime3,	60000000/thisTempo // thus microseconds per quarter note
);
}

^\[\]m:{_}[0-9]+"/"[0-9+]	{uint32_t n=0,d=0; sscanf(YYP, "%u/%u",&n,&d); CHK(n*n);
	if (TO==0||LY) ++I, do_tmsig(Do?tM+of[I]:0, YTR channel, n,d, YYP, meas1);}


^\[\]t:{_}{NALT} FALLTHROUGH;
^\[\]z:{_}{NALT} FALLTHROUGH;
^\[\]ly{_}{NALT}	{CQ
	#// Lyrics demarcated by double spaces.
	while (YYG yy_hold_char) {
		if (YYG yy_hold_char == '\\'	||
		   !YYG yy_hold_char)		break;
		if (YYG yy_hold_char != ' '	&&
		    YYG yy_hold_char != ALTSPC)	yyless(YYL+1);
	else	if (YYT[YYL+1] == ' '		||
		    YYT[YYL+1] == ALTSPC	||
		   !YYT[YYL+1])			break;
	else	if (YYT[YYL+1] != ' '		||
		    YYT[YYL+1] == ALTSPC)	yyless(YYL+1);
	}
	if (YYT[YYL]== ' ' || YYT[YYL]==ALTSPC) yyless(YYL-1);
	if (YYT[2]=='l')	do(_lyrics, YYP);
else	if (YYT[2]=='t')	strcpy((ALL(title) MYYL+1), YYP);
else				strcpy((ALL(copyr) MYYL+1), YYP);
}

^\[\]("PI"|"pi"|"IP"|"ip"){_}[)!@#$%\^&*(0-9][a-gA-G]	FALLTHROUGH;
^\[\]("PI"|"pi"|"IP"|"ip"){_}[a-gA-G][)!@#$%\^&*(0-9]	{Q
_Bool	isFlattened = YYT[2]<'Z', isWait=0, doAlt=1;
char	h=YYP[0],
	isMinus = (YYT[YYL-1]/32) >= 2 && ((uint8_t)((YYT[YYL-1] % 32) - 1) <= 'G' - 'A')?-1:1;
	if (YYT[2]/32 >= 2 && YYT[2]%32 == 'I'%32) isWait=isMinus==-1?1:0, isMinus=1; //why'd I subtract one?
	if (isWait||isMinus==-1) YYP[0]=YYP[1],YYP[1]=h;
 int8_t	let = YYP[0];
uint8_t	num = YYP[1];
_Bool	isFlat =	( isFlattened && let>='a') ||	(!isFlattened && num-'0' > 9),
	isSharp =	(!isFlattened && let<'a') ||	( isFlattened && num-'0' > 9),
	isDSharp =	isFlattened==0&&isSharp&&(num<'0'||num>'9'),
	isDFlat =	isFlattened&&isFlat&&(num<'0'||num>'9');
	#// Pitch: a letter and a number of octaves below or above that above a common C.
	#// This common C is the 0th C, and middle C is C3.
	#// If the number precedes the letter we subtract octaves.
	#// In []pi sharpened pitch, a note is natural unless it is SHARPCASED.
	#// In []PI FLATTENED pitch, a note is NATURAL unless it is flatcased.
	#// Uppercase numbers )!@#$%^&*( make these into double sharps/flats.
	#// Unless the letter is cased like a natural - then it's a flat/sharp.

	#// Demonstrating two plain chromatic C scales:
	#// []PI C4d4D4e4E4F4g4G4a4A4b4B4C5
	#// []pi c4C4d4D4e4f4F4g4G4a4A4b4C5

	#// Demonstrating a crazy though valid C scale:
	#// []PI C4d4----E4------G$b$--c4d%
	#// []pi ----d4D4--f4F4F$----b$----

	#// Note that []PI c4 is "the fourth C-flat" rather than "the fourth C, flat".

if	((num-='0')<=9?doAlt=0:1) switch(num+='0'){ //+= avoids error
	case ')': num = 0;break; // Uppercase numbers, per typical American keyboard.
	case '!': num = 1;break; // to do: add safe Euro equivalents
	case '@': num = 2;break;
	case '#': num = 3;break;
	case '$': num = 4;break;
	case '%': num = 5;break;
	case '^': num = 6;break;
	case '&': num = 7;break;
	case '*': num = 8;break; // non-uppercase ones done by if stment
	case '(': num = 9;break;} if (!LY) switch(let) {
	case 'c': let= isFlattened?12:0 ;break;
	case 'C': let= 1 ;break;
	case 'd': let=-2 ;break;
	case 'D': let= 3 ;break;
	case 'e': let=-4 ;break;
	case 'E': let= 5 ;break;
	case 'f': let=-5 ;break;
	case 'F': let= 6 ;break;
	case 'g': let=-7 ;break;
	case 'G': let= 8 ;break;
	case 'a': let=-9 ;break;
	case 'A': let= 10;break;
	case 'b': let=-11;break;
	case 'B': let= isFlattened?12:24;break;
}
	int ab=0, fl=0;
	if (LY) let=((YYP[0]-1)%32)+1, ab=let-1+7*((let<3)+num*isMinus)-21,
		fl=isDSharp?SHD:isDFlat?FLD:isFlat?FLT:isSharp?SHP:0;
	else	ab=abs(let+doAlt)-isFlattened+12*num*isMinus-36; //36 is C2
	if (!isWait && push(ab,(uint32_t**)&aboveCs) && push(fl,&isFlt)) BREAK(MYYL);
	YTR aboveC = ab;
	YTR isFl = fl;
	YYC->charsAftTil += YYP[1] = 1;
	YYC->skipMany = 0;
	RETQUITIFLAST;
	break;
}

^\[\]("IP"|"ip"){_}\x01	Q push(YTR aboveC,(uint32_t**)&aboveCs), push(YTR isFl,&isFlt), YTR isFl=YTR aboveC=0;

^\[\]CL{_}[GCFt]	Q do(_clef, *YYP);


^\[\]vy{_}pppp	{
	#// []vy first-layer velocity: common interpretations of "forte" and other sheet-music terms.
	#// This velocity is applied until another line is found that's had a velocity specified.
	#// It is re-applied in subsequent columns.
		Q veloc=doVeloc(8); }
^\[\]vy{_}ppp	Q veloc=doVeloc(20);
^\[\]vy{_}pp	Q veloc=doVeloc(31);
^\[\]vy{_}p	Q veloc=doVeloc(42);
^\[\]vy{_}mp	Q veloc=doVeloc(53);
^\[\]vy{_}mf	Q veloc=doVeloc(64);
^\[\]vy{_}f	Q veloc=doVeloc(80);
^\[\]vy{_}ff	Q veloc=doVeloc(96);
^\[\]vy{_}fff	Q veloc=doVeloc(112);
^\[\]vy{_}ffff	Q veloc=doVeloc(127);

^\[\]Vy{_}[a-z]	{Q
	#// []Vy second-layer velocity: enable 1-or-2char hexadecimal covering of all MIDI velocities (when uppercase)
	#// and (when lowercase) a 1char covering of "many" MIDI velocities with range a-z.
	#// "Pianissimo" and friends disallowed here.
	veloc = doVeloc((*YYP - 'a') * 127 / 25); }
^\[\]Vy{_}[0-9A-F]{1,2}	{Q
	unsigned a; sscanf(YYP,"%x",&a);
	FF("Excess velocity capped at quadruple forte ('ffff', CAPS HEX '%x')");
	veloc=doVeloc(a);
	
}
^\[\]V[0-9Y]{_}[a-z]+;{0,1}	%{Q
	#// []VY third-layer velocity: when digit substituted for Y in "VY", allow compact stacking of several velocities.
	#// After all velocities are popped off of stack (by equal number of notes), discard stack.
	#// At that point abide by []vy and []Vy rules. []V0 isn't zero but ten, incidentally, and []VY is just one.
	#define until meas1
	until = 16;
	if (YYT[3]<'@')	until = YYT[3] - '0';			// hex numbers
	//else			until = YYT[3] - '@' + 9;	// hex letters
	else if (YYT[3]=='0')	until = 10;			// zero isn't zero but 10
	else			until = 1;
	for (uint8_t ii=0; ii<MYYL&&ii<until; ++ii) {
		if   (YYP[ii] == ';') break;
		push((YYP[ii] - 'a') * 127 / 25, &velocs);
		if   (ii == 255)	  break;
	}
	
#// Flex-style braces with % needed here for Flex 2.6.2
%}
^\[\]cv{_}[0-9]{1,3}	{CQ unsigned a;sscanf(YYP,"%u",&a); FF("Excess channel volume caps to %u"); do(_cc,0x7,a);}
^\[\]bl{_}-?[0-9]{1,2}	{CQ int a;sscanf(YYP,"%d",&a); HF("Excess balance caps to %d"); do(_cc,0x8,a+64);}
^\[\]pn{_}-?[0-9]{1,2}	{CQ int a;sscanf(YYP,"%d",&a); HF("Excess pan caps to %d"); do(_cc,0xA,a+64);}
}


<MEASURES,FIRSTMEAS>{
	/* m4_append([[MEASCHR]],[[\\]]) */
^\[\]..{_}\\	P
	/* m4_append([[MEASCHR]],[[|]]) */
^\[\]..{_}\|	P
	/* m4_append([[MEASCHR]],[[:]]) */
^\[\]..{_}:	{P for (uint32_t i=1; repeatFr NN&&i<=*repeatFr;) if (repeatFr[i++]==meas1) BREAK(MYYL);
		push(1,&repeatTo); push(meas1,&repeatFr);} //must later account for repeats in mFro
<<EOF>>
}

<SQUARES,MEASURES,FIRSTRUN,FIRSTMEAS>{
^\[\]Ss{_}[Ss]|[0-9]{1,3}	CQ int a; if (*YYP=='s'||*YYP=='S') a=*YYP!='s'; else (sscanf(YYP,"%d",&a)); do(_cc,0x40,a+63);
^\[\]..{_}.
}
		    /* m4_append([[COMM1]],[[*]])m4_append([[COMM1]],[[/]])*/
		    /* m4_append([[COMM2]],[[/]])m4_append([[COMM2]],[[*]])*/
		    /* COMM1 #define CHARSTRING m4_defn([[RHYMWID]]) COMM2 */
		    /* COMM1 #define MEASSTRING m4_defn([[MEASCHR]]) COMM2 */

%%

#define RMK(x)	    #x
#define MKR(x)	    RMK(x)
		    CN char *widR = MKR(CHARSTRING);
		    CN char *measchr = MKR(MEASSTRING);
/* char *widR now declared/initialized */
#ifndef CHARSTRING
#warning Preprocessor failure in tfm.l! Search for "m4_" in code.
#endif

#include <ctype.h>

#define CAPSR(x) (x<96)

char myStrCmp (CN char* str, CN char* sts, uint8_t capsToo, CN char* prv);
char myStrCmp (CN char* str, CN char* sts, uint8_t capsToo, CN char* prv) { capsToo*=16;
int nib=0, ble=strlen(str), b=strlen(sts), rem; if (ble<2) return 0;
for (; nib<b/ble; ++nib) {
	for (rem=ble; rem>0; --rem)
		if(abs(str[rem-1]-sts[nib*ble+rem-1]+capsToo)-capsToo&&sts[nib*ble+rem-1]^'*') break;
	if (!rem) return 1 + (toupper(prv[0])==toupper(str[1])&&
			      toupper(prv[1])==toupper(str[1]))*2 + CAPSR(str[1])*4;
}
return 0;
}

#include "main.c"
